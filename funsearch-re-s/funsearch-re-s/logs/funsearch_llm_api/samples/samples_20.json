{"sample_order": 20, "function": "def priority(sorted_combinations: dict) -> tuple[int, int, int]:\n    \"\"\"\n    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,\n    and remove it from the list.\n    The function that determine the priority should be generated by LLM\n\n    Args:\n        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.\n\n    Returns:\n        tuple[int, int, int], the combination that is prioritised,\n        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.\n\n    \"\"\"\n    \"\"\"\n    A more intricate function for determining prioritisation of task allocation,\n    emphasizing tasks that strike a balance between coverage maximization and equitable task distribution.\n    \n    Args:\n        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.\n    \n    Returns:\n        tuple[int, int, int], the combination that is prioritised,\n        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.\n    \"\"\"\n\n    # Initialize a dictionary to keep track of the number of tasks allocated per satellite\n    satellite_task_count = {}\n    for key in sorted_combinations.keys():\n        satellite_idx = key[0]\n        if satellite_idx not in satellite_task_count:\n            satellite_task_count[satellite_idx] = 0\n\n    # Select the task that either covers the most points or helps in balancing workloads across satellites\n    for key, value in sorted_combinations.items():\n        satellite_idx, _, _ = key\n\n        # Prioritize spreading tasks among satellites\n        min_tasks = min(satellite_task_count.values())\n        satellites_with_min_tasks = [sat for sat, count in satellite_task_count.items() if count == min_tasks]\n\n        # If the current satellite has the least allocated tasks, or there's a tie, prioritize by coverage\n        if satellite_idx in satellites_with_min_tasks:\n            # Additionally, check if the task covers more points than a simple minimum threshold\n            if len(value) > 2:  # Example threshold\n                satellite_task_count[satellite_idx] += 1\n                return key  # This task is prioritized\n\n    # In case no task meets the criteria, fall back to picking the task with the maximum coverage\n    # This is a simple fallback and might not be reached depending on the criteria above\n    max_coverage_key = max(sorted_combinations, key=lambda k: len(sorted_combinations[k]))\n    satellite_idx = max_coverage_key[0]\n    satellite_task_count[satellite_idx] += 1\n    return max_coverage_key\n\n", "score": 43.14493587539501}