{"sample_order": 17, "function": "def priority(sorted_combinations: dict) -> tuple[int, int, int]:\n    \"\"\"\n    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,\n    and remove it from the list.\n    The function that determine the priority should be generated by LLM\n\n    Args:\n        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.\n\n    Returns:\n        tuple[int, int, int], the combination that is prioritised,\n        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.\n\n    \"\"\"\n    \"\"\"\n    This improved version of `priority_v0` function aims to optimize the allocation by ensuring \n    that tasks with the greatest achievable coverage are prioritized while considering \n    the satellite and pass indices to handle edge cases where multiple tasks may have \n    similar coverage. This is crucial as it can handle cases where we have limited resources \n    (in this case, satellites) and need to optimize their usage.\n\n    Args:\n        sorted_combinations: dict of sorted task combinations where key is a tuple of indices \n        (satellite index, pass index, task index) and the value is a tuple of indices of points \n        that can be covered by the given task.\n\n    Returns:\n        tuple[int, int, int] (satellite index, pass index, task index) of the prioritized task.\n    \"\"\"\n    # initialize maximum coverage value and max_combination tuple\n    max_coverage = -1\n    max_combination = ()\n\n    # iterate over sorted combination keys (indices)\n    for key in sorted_combinations.keys():\n\n        # at each iteration, initialize variables for the current satellite, pass and task indices\n        current_satellite, current_pass, current_task = key\n\n        # calculate the potential coverage value for the current task\n        # by calculating the length of the corresponding value in the sorted_combinations dict\n        current_coverage = len(sorted_combinations[key])\n\n        # prioritize tasks with higher coverage and if there are multiple tasks with same coverage\n        # prioritize the task with the higher pass index and if still the same, then prioritize \n        # task with the higher satellite index\n        if current_coverage > max_coverage or \\\n                (current_coverage == max_coverage and current_pass > max_combination[1]) or \\\n                (current_coverage == max_coverage and current_pass == max_combination[1] and current_satellite > max_combination[0]):\n\n            max_coverage = current_coverage\n            max_combination = key\n\n    # return the keys (indices) of the highest priority task\n    return max_combination\n\n", "score": 63.349917081260365}