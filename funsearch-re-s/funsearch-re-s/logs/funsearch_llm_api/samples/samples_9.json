{"sample_order": 9, "function": "def priority(sorted_combinations: dict) -> tuple[int, int, int]:\n    \"\"\"\n    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,\n    and remove it from the list.\n    The function that determine the priority should be generated by LLM\n\n    Args:\n        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.\n\n    Returns:\n        tuple[int, int, int], the combination that is prioritised,\n        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.\n\n    \"\"\"\n    \"\"\"\n    Allocate a priority to task combinations based on more complex rules involving patterns of coverage.\n\n    Args:\n        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The dict is sorted in ascending order on the number of points that can be covered.\n\n    Returns:\n        tuple[int, int, int], the combination that is prioritised,\n        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.\n\n    \"\"\"\n    # Define patterns of interest in coverage\n    considered_patterns = [(2,), (1, 3), (4, 2), (3,)]\n\n    max_coverage_length = 0\n    priority_key = ()\n\n    for key, coverage in sorted_combinations.items():\n        coverage_length = len(coverage)\n        if coverage_length < 2:\n            continue  # Skip tasks with less than 2 points of coverage\n\n        coverage_difference = set(np.diff(coverage))\n        # Check if coverage pattern matches any considered pattern\n        for pattern in considered_patterns:\n            if all(elem in coverage_difference for elem in pattern):\n                # Prioritize by longest matching coverage and then by total coverage length\n                if coverage_length > max_coverage_length:\n                    max_coverage_length = coverage_length\n                    priority_key = key\n                break  # Exit loop once a match is found as one match per task is enough\n\n        if max_coverage_length == 0:\n            # If no pattern matches, prioritize based on the largest coverage length\n            if len(coverage) > max_coverage_length:\n                max_coverage_length = len(coverage)\n                priority_key = key\n\n    # If no specific patterns found and all tasks have less than 2 points of coverage, fallback to prioritizing the first task with any coverage\n    if max_coverage_length == 0 and sorted_combinations:\n        for key, coverage in sorted_combinations.items():\n            if coverage:\n                priority_key = key\n                break\n\n    return priority_key\n\n", "score": 40.17474334954284}