================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    return 0
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_coverage = 0
    selected_combination = None
    
    # Loop through all combinations in sorted order
    for combination, coverage in sorted_combinations.items():
        # Check if the coverage of the current combination is greater than the previous maximum coverage
        if len(coverage) > max_coverage:
            max_coverage = len(coverage)
            selected_combination = combination
        # If the coverage is equal to the maximum coverage, prioritize based on different criteria
        elif len(coverage) == max_coverage:
            # Priority criteria 1: prioritize tasks from satellite with lower index
            if combination[0] < selected_combination[0]:
                selected_combination = combination
            # Priority criteria 2: prioritize tasks from pass with lower index
            elif combination[0] == selected_combination[0] and combination[1] < selected_combination[1]:
                selected_combination = combination
            # Priority criteria 3: prioritize tasks from task with lower index
            elif combination[0] == selected_combination[0] and combination[1] == selected_combination[1] and combination[2] < selected_combination[2]:
                selected_combination = combination
    
    return selected_combination
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if value:
            return key
    return None
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if value:  # Check if there are points that can be covered by the task
            return key
    return (0, 0, 0)  # Return a default value if no task can cover any point
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            return key
    return None
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if value:  # If the task can cover at least one point
            return key
    return (0, 0, 0)  # If no task can cover any point, return a default value.
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) == 0:
            continue
        else:
            return key
    return None
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if value:  # Check if the task can cover any point
            return key
    return tuple(sorted_combinations.keys())[0]  # If no task can cover any point, return the first task in the sorted combinations
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            task_id = key[2]
            return task_id
    return -1  # if no task can cover any point, return -1 as an indication of no prioritised task.
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if value:  # If the task can cover at least one point
            return key
        elif is_divisible(key[0], key[1], key[2]):
            return key
        else:
            for index, val in enumerate(value):
                if is_special_case(key, index, val):
                    return key
    return (0, 0, 0)
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            return key
            
    max_points = -1
    max_key = (0, 0, 0)
    for key, value in sorted_combinations.items():
        if len(value) > max_points:
            max_key = key
            max_points = len(value)
    
    return max_key
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if value:  # If the task can cover at least one point
            return key
        elif len(key) == 3 and key[1] > 0:  # If pass index is greater than 0
            return key
        else:
            for k, v in sorted_combinations.items():
                if k[1] == 0:  # If pass index is 0
                    return k
    return (0, 0, 0)  # If no task can cover any point, return a default value.
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_points = 0
    prioritized_task = (0, 0, 0)

    for key, value in sorted_combinations.items():
        if value:
            points_covered = len(value)
            if points_covered > max_points:
                max_points = points_covered
                prioritized_task = key
            elif points_covered == max_points:
                # Choose the one with the smaller task index
                if key[2] < prioritized_task[2]:
                    prioritized_task = key

    return prioritized_task
-----------------------------------------------------
Score: 55.22072290171147
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            return key
    return None
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            return key
    return (0, 0, 0)
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            return key
    return (0, 0, 0)
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            return key
    return None
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if value:  # Check if there are points that can be covered by the task
            if key[0] % 2 == 0:  # If the satellite index is even, prioritize it
                return key
    return 0, 0, 0
-----------------------------------------------------
Score: 20.962974268291823
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) <= 5:
            return key
    for key, value in sorted_combinations.items():
        if len(value) <= 10:
            return key
    # Add more conditions as needed
    return 0, 0, 0
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) == 0:
            continue
        for task_index in key[2]:
            if task_index % 2 == 0:
                continue
            return key
    return (0, 0, 0)
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key in sorted_combinations.keys():
        if len(sorted_combinations[key]) > 0:
            return key
    return None
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if condition_1:
            # do something
            return key
        elif condition_2:
            # do something
            return key
        else:
            # do something
            return key
    return 0, 0, 0  # default return value if no combination is prioritised
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            return key
    return 0, 0, 0
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) >= 3:
            return key
    for key, value in sorted_combinations.items():
        if len(value) >= 2:
            return key
    for key, value in sorted_combinations.items():
        if len(value) >= 1:
            return key

    return next(iter(sorted_combinations.keys()))
-----------------------------------------------------
Score: 43.14493587539501
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if not value:
            continue
        task_id = key[2]
        coverage_points = value
        priority_score = len(coverage_points) + task_id * 0.1
        if priority_score > 5:
            return key
    return next(iter(sorted_combinations.keys()))
-----------------------------------------------------
Score: 45.18097687397521
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    highest_priority = None
    highest_priority_score = 0
    
    # Iterate through the sorted combinations to find the highest priority task
    for combination, coverage in sorted_combinations.items():
        task_id = combination[2]
        coverage_points = len(coverage)
        coverage_score = coverage_points * 10  # Define a scoring mechanism based on coverage points
        
        # You can add more conditions to adjust the priority score based on specific criteria
        if coverage_points > 5:
            coverage_score += 20
        elif coverage_points > 0:
            coverage_score += 10
        
        # Update the highest priority task if the current task has a higher score
        if coverage_score > highest_priority_score:
            highest_priority = combination
            highest_priority_score = coverage_score
    
    return highest_priority
-----------------------------------------------------
Score: 55.032021369410586
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            min_distance = float('inf')  # Initialize minimum distance as infinity
            selected_key = None
            for k, v in sorted_combinations.items():
                if len(v) > 0:
                    distance = calculate_distance(key, k)
                    if distance < min_distance:
                        min_distance = distance
                        selected_key = k
            return selected_key
    return None
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            if key[0] % 2 == 0:  # If satellite index is even
                return key
            elif key[1] % 2 == 0:  # If pass index is even
                return key
            else:  # If neither satellite index nor pass index is even
                for index in value:
                    if index % 2 == 0:  # If any covered point index is even
                        return key
    return None
-----------------------------------------------------
Score: 37.554411768145634
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            if key[0] == 0:
                return key
            else:
                for i in range(len(value)):
                    if i % 2 == 0:
                        return key
    return None
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            for index in range(len(value)):
                if value[index] % 2 == 0:
                    return key
    return None
-----------------------------------------------------
Score: 38.74281624318464
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key in sorted_combinations.keys():
        if len(sorted_combinations[key]) > 0 and key[0] % 2 == 0:  # Filter out even satellite indices
            for point in sorted_combinations[key]:
                if point[1] > 50:  # Filter out points with latitude greater than 50
                    return key
    for key in sorted_combinations.keys():
        if len(sorted_combinations[key]) > 0:
            return key
    return None
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            return key
        else:
            max_points = -1
            max_key = None
            for k, v in sorted_combinations.items():
                if len(v) > max_points:
                    max_points = len(v)
                    max_key = k
            return max_key
    return None
-----------------------------------------------------
Score: 55.032021369410586
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key in sorted_combinations.keys():
        # Check if the coverage list is not empty
        if len(sorted_combinations[key]) > 0:
            # Check if the satellite index is even
            if key[0] % 2 == 0:
                # Check if the pass index is less than 5
                if key[1] < 5:
                    # Return the key if all conditions are met
                    return key
    return None
-----------------------------------------------------
Score: 5.062165664390787
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    n_points = np.inf
    chosen_key = None
    for key in sorted_combinations.keys():
        if len(sorted_combinations[key]) < n_points:
            n_points = len(sorted_combinations[key])
            chosen_key = key
            
    if n_points == 0:
        return None
    else:
        return chosen_key
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_points = 0
    max_distance = 0
    prioritized_task = (0, 0, 0)

    for key, value in sorted_combinations.items():
        if value:
            points_covered = len(value)
            if points_covered > max_points:
                max_points = points_covered
                prioritized_task = key
            elif points_covered == max_points:
                # Choose the one with the smaller task index
                if key[2] < prioritized_task[2]:
                    prioritized_task = key
                elif key[2] == prioritized_task[2]:
                    # Calculate the distance from the satellite to the task
                    satellite_pos = dataset.get_satellite_position(key[0])  # Get satellite position
                    task_pos = dataset.get_task_position(key[2])  # Get task position
                    distance = sqrt((task_pos[0] - satellite_pos[0]) ** 2 + (task_pos[1] - satellite_pos[1]) ** 2)
                    if distance > max_distance:
                        max_distance = distance
                        prioritized_task = key

    return prioritized_task
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_points = 0
    prioritized_task = (0, 0, 0)

    for key, value in sorted_combinations.items():
        if value:
            points_covered = len(value)
            if points_covered > max_points:
                max_points = points_covered
                prioritized_task = key
            elif points_covered == max_points:
                for i in range(len(prioritized_task)):
                    if key[i] < prioritized_task[i]:
                        prioritized_task = key
                        break

    return prioritized_task
-----------------------------------------------------
Score: 54.93670575191742
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_points = 0
    max_distance = 0
    prioritized_task = (0, 0, 0)

    for key, value in sorted_combinations.items():
        if value:
            points_covered = len(value)
            distance_sum = sum([sqrt((point[0] ** 2) + (point[1] ** 2)) for point in value])

            if points_covered > max_points:
                max_points = points_covered
                max_distance = distance_sum
                prioritized_task = key
            elif points_covered == max_points:
                if distance_sum > max_distance:
                    max_distance = distance_sum
                    prioritized_task = key
                elif distance_sum == max_distance:
                    if key[2] < prioritized_task[2]:
                        prioritized_task = key

    return prioritized_task
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_weights = 0
    prioritized_task = (0, 0, 0)

    for key, value in sorted_combinations.items():
        if value:
            points_covered = len(value)
            weights = points_covered * (key[0] + key[1] + key[2])  # incorporating weights based on satellite, pass, and task indices
            if weights > max_weights:
                max_weights = weights
                prioritized_task = key
            elif weights == max_weights:
                # Choose the one with the smaller task index
                if key[2] < prioritized_task[2]:
                    prioritized_task = key

    return prioritized_task
-----------------------------------------------------
Score: 54.0232254337153
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Improved version of `priority_v1`.
    """
    max_points = 0
    max_distance = 0
    prioritized_task = (0, 0, 0)

    for key, value in sorted_combinations.items():
        if value:
            points_covered = len(value)

            total_distance = 0
            for point in value:
                total_distance += sqrt(point[0] ** 2 + point[1] ** 2)

            if points_covered > max_points:
                max_points = points_covered
                max_distance = total_distance
                prioritized_task = key
            elif points_covered == max_points:
                # Choose the one with the smaller total distance of points covered
                if total_distance < max_distance:
                    max_distance = total_distance
                    prioritized_task = key
                elif total_distance == max_distance:
                    # Choose the one with the smaller task index
                    if key[2] < prioritized_task[2]:
                        prioritized_task = key

    return prioritized_task
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_points = 0
    max_distance = 0
    prioritized_task = (0, 0, 0)

    for key, value in sorted_combinations.items():
        if value:
            points_covered = len(value)
            avg_x = sum([point[0] for point in value]) / points_covered
            avg_y = sum([point[1] for point in value]) / points_covered
            avg_distance = sqrt(avg_x ** 2 + avg_y ** 2)

            if points_covered > max_points:
                max_points = points_covered
                prioritized_task = key
            elif points_covered == max_points:
                if avg_distance > max_distance:
                    max_distance = avg_distance
                    prioritized_task = key
                elif avg_distance == max_distance:
                    if key[2] < prioritized_task[2]:
                        prioritized_task = key

    return prioritized_task
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_points = 0
    prioritized_task = (0, 0, 0)

    for key, value in sorted_combinations.items():
        if value:
            points_covered = len(value)
            if points_covered > max_points:
                max_points = points_covered
                prioritized_task = key
            elif points_covered == max_points:
                # Choose the one with the smaller task index
                if key[2] < prioritized_task[2]:
                    prioritized_task = key
            else:
                satellite_index, pass_index, task_index = key
                sum_data = sum([value for value in value])
                if sum_data > 1000:
                    prioritized_task = key
                else:
                    x = 0
                    y = 0
                    for val in value:
                        x += val[0]
                        y += val[1]
                    distance = sqrt(x**2 + y**2)
                    if distance < 500:
                        prioritized_task = key

    return prioritized_task
-----------------------------------------------------
Score: 55.22072290171147
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            return key
    return (0, 0, 0)
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) == 0:
            continue
        else:
            return key
    return 0, 0, 0
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            return key
    return None
-----------------------------------------------------
Score: 37.51915083725706
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        # Check if the task can cover any points
        if value:
            # Check if the coverage is at least 50 points
            if len(value) >= 50:
                return key
    # If no task has sufficient coverage, prioritize the task with the maximum coverage
    max_coverage_task = max(sorted_combinations, key=lambda x: len(sorted_combinations[x]))
    return max_coverage_task
-----------------------------------------------------
Score: 55.032021369410586
=====================================================


