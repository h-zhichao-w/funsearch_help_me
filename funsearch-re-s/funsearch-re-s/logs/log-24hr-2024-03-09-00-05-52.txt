================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    return list(sorted_combinations.keys())[-1]
-----------------------------------------------------
Score: 0.003400327932503444
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_coverage = 0
    max_key = None
    
    for key, value in sorted_combinations.items():
        num_coverage = len(value)
        if num_coverage > max_coverage:
            max_coverage = num_coverage
            max_key = key
            
    if max_key is None:
        return list(sorted_combinations.keys())[-1]
    
    return max_key
-----------------------------------------------------
Score: 0.44802136941058635
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for combination in sorted_combinations.keys():
        if len(sorted_combinations[combination]) > 0:
            return combination
    return list(sorted_combinations.keys())[0]
-----------------------------------------------------
Score: -17.064849162742938
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            return key
    return list(sorted_combinations.keys())[0]
-----------------------------------------------------
Score: -17.064849162742938
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_coverage_area = 0
    selected_task = None
    
    # Iterate through the sorted combinations to find the task with maximum coverage area
    for key, value in sorted_combinations.items():
        if len(value) > max_coverage_area:
            max_coverage_area = len(value)
            selected_task = key
    
    # If no task with coverage area is found, return the task with the minimum number of points covered
    if selected_task is None:
        return list(sorted_combinations.keys())[0]
    
    return selected_task
-----------------------------------------------------
Score: 0.44802136941058635
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            return key
    return list(sorted_combinations.keys())[0]
-----------------------------------------------------
Score: -17.064849162742938
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    total_coverage = sum([len(points) for points in sorted_combinations.values()])
    max_coverage = len(sorted_combinations[list(sorted_combinations.keys())[-1]])
    
    if total_coverage < 100:
        return list(sorted_combinations.keys())[0]
    
    elif total_coverage >= 100 and max_coverage >= 10:
        return list(sorted_combinations.keys())[0]
    
    else:
        return list(sorted_combinations.keys())[-1]
-----------------------------------------------------
Score: -54.584
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) >= 3:
            return key
        elif len(value) == 2:
            max_distance = 0
            max_key = key
            for k, points in sorted_combinations.items():
                if len(points) > 0:
                    distance = sqrt((key[0] - k[0])**2 + (key[1] - k[1])**2)
                    if distance > max_distance:
                        max_distance = distance
                        max_key = k
            return max_key
    return list(sorted_combinations.keys())[0]
-----------------------------------------------------
Score: -14.340664491365454
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) > 0:
            return key
    return list(sorted_combinations.keys())[0]
-----------------------------------------------------
Score: -17.064849162742938
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    total_points = sum([len(points) for points in sorted_combinations.values()])

    if total_points <= 10:
        return list(sorted_combinations.keys())[-1]

    max_coverage = 0
    max_coverage_key = None
    for key, value in sorted_combinations.items():
        if len(value) > max_coverage:
            max_coverage = len(value)
            max_coverage_key = key
    
    if max_coverage_key:
        return max_coverage_key
    else:
        return list(sorted_combinations.keys())[-1]
-----------------------------------------------------
Score: 0.44802136941058635
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    for key, value in sorted_combinations.items():
        if len(value) >= 3:
            return key
    for key, value in sorted_combinations.items():
        if len(value) >= 2:
            return key
    return list(sorted_combinations.keys())[0]
-----------------------------------------------------
Score: -11.539613329684443
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_coverage = 0
    max_key = None
    
    for key, value in sorted_combinations.items():
        num_coverage = len(value)
        if num_coverage > max_coverage:
            max_coverage = num_coverage
            max_key = key
    
    if max_key is None:
        return list(sorted_combinations.keys())[-1]
    
    max_score = 0
    max_score_key = None
    
    for key, value in sorted_combinations.items():
        score = len(value) * 0.5 + key[0] * 0.3 + key[1] * 0.2
        if score > max_score:
            max_score = score
            max_score_key = key
    
    if max_score_key is None:
        return max_key
    
    return max_score_key
-----------------------------------------------------
Score: -6.068935454368965
=====================================================


