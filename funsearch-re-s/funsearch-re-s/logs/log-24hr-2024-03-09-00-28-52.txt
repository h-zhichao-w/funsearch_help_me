================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    return sorted(sorted_combinations.keys())[0]
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The improved algorithm will prioritize the tasks with most covered points first. If two tasks have
    an equal number of covered points, the one with the lower satellite index will be prioritized.

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised, in the format of [satellite index, pass index, task index]
    """
    # sort the keys (task combinations) by the length of the covered points in descending order, 
    # if both have same number of points, sort by the first element (satellite index) in ascending order
    sorted_keys = sorted(sorted_combinations.keys(), key=lambda k: (-len(sorted_combinations[k]), k[0]))

    # return the first key from the sorted keys list
    return sorted_keys[0]
-----------------------------------------------------
Score: 54.94386904218915
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Improved version of `priority_v0` but in this method, if there are multiple tasks with the same number
    of coverages, it considers the index of task as well. Lower index task has higher priority.

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverages. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the numbers of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    # create copy of sorted_combinations to avoid modifying original dict
    sorted_combinations_copy = copy.deepcopy(sorted_combinations)

    # Get list of keys for tasks with maximum coverage
    max_coverage_keys = [
        key for key in sorted_combinations_copy.keys()
        if len(sorted_combinations_copy[key]) == len(sorted_combinations_copy[list(sorted_combinations_copy.keys())[-1]])
    ]

    if len(max_coverage_keys) == 1:
        # If there is only one task with maximum coverage, return it
        return max_coverage_keys[0]
    else:
        # If there are multiple tasks with the same maximum coverage, return the one with the lowest task index
        return min(max_coverage_keys, key=lambda x: x[2])
-----------------------------------------------------
Score: 55.22072290171147
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
  
    # Prioritize the tasks based on the number of points covered and break ties based on satellite index and pass index.
    # This could be adjusted based on the specifics of the task allocation problem at hand.
    prioritized_combinations = sorted(sorted_combinations.items(), key=lambda item: (len(item[1]), item[0][0], item[0][1]))

    if prioritized_combinations:
        return prioritized_combinations[0][0]
    else:
        return None
-----------------------------------------------------
Score: 0.0
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Improved version of `priority_v0`. Instead of simply getting the first 
    task from the sorted list, the function takes into account the size of 
    covered points. The task with maximum number of coverage points will be 
    prioritised.

    Args:
        sorted_combinations: dict, sorted combinations of task id and its 
        coverage. The key is a tuple, in the format of [index of satellite, 
        index of pass, index of task], and the value is a tuple, containing 
        the indices of points that can be covered by the task. The tuple is 
        likely to be empty, and if so, it means that the corresponding task 
        cannot cover any point. The dict is sorted in ascending order on the 
        number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e., 
        the key of the prioritised task.
    """
    max_coverage = -1
    prioritised_task = None

    for task, coverage in sorted_combinations.items():
        coverage_len = len(coverage)
        if coverage_len > max_coverage:
            max_coverage = coverage_len
            prioritised_task = task
    
    return prioritised_task
-----------------------------------------------------
Score: 55.032021369410586
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    In this version, we additionally give priority to tasks which cover unique points that are covered by no other tasks. 

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    # Count how many times each point appears across all tasks
    point_counts = {}
    for points in sorted_combinations.values():
        for point in points:
            point_counts[point] = point_counts.get(point, 0) + 1

    # Create a list of tasks, sorted by their priority
    # Priority is based first on the number of unique points the task covers, then on the total number of points
    sorted_tasks = sorted(
        sorted_combinations.items(),
        key=lambda item: (
            -len([point for point in item[1] if point_counts[point] == 1]),
            -len(item[1]),
        ),
    )

    # Return the id of the task with the highest priority
    return sorted_tasks[0][0] if sorted_tasks else None
-----------------------------------------------------
Score: 54.49787381849568
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Improved version of `priority_v0`. 
    In this version, let's prioritize tasks that cover the most points.
    If multiple tasks cover the same maximum number of points, then we'll
    choose the task belonging to the satellite with the least number of allocated tasks.

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage.
        Keys are in the format of [index of satellite, index of pass, index of task]
        Values are tuples containing indices of points that can be covered by the task.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index].
    """

    # Group tasks by the number of points they can cover
    coverage_groups = {}
    for task, coverage in sorted_combinations.items():
        num_points = len(coverage)
        if num_points not in coverage_groups:
            coverage_groups[num_points] = []
        coverage_groups[num_points].append(task)

    # Find the group that covers the most points
    max_coverage = max(coverage_groups.keys())
    max_coverage_group = coverage_groups[max_coverage]

    # Within the group, find the satellite with the least number of tasks
    task_counts = {}
    for task in max_coverage_group:
        satellite_index = task[0]
        if satellite_index not in task_counts:
            task_counts[satellite_index] = 0
        task_counts[satellite_index] += 1

    min_task_count = min(task_counts.values())
    prioritised_satellites = [sat for sat, count in task_counts.items() if count == min_task_count]

    # If there are multiple satellites with the same minimum number of tasks,
    # just pick the first one (could further prioritize if needed)
    for task in max_coverage_group:
        if task[0] in prioritised_satellites:
            return task

    # If no task was found (unlikely), just return the first task
    return next(iter(sorted_combinations.keys()))
-----------------------------------------------------
Score: 54.94386904218915
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Improved version of `priority_v0`. 
    Prioritise the combination which has maximum coverage.
    If a tie situation occurs, choose the task which comes earlier (based on the satellite index).
    And remove it from the list.

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index].
    """

    # Find the task with maximum coverage
    max_coverage = max(len(value) for value in sorted_combinations.values())
    max_coverage_tasks = [key for key, value in sorted_combinations.items() if len(value) == max_coverage]

    # if there are multiple tasks with same maximum coverage, select the task comes first (based on satellite index)
    if len(max_coverage_tasks) > 1:
        return min(max_coverage_tasks, key=lambda task: task[0])
    else:
        return max_coverage_tasks[0]
-----------------------------------------------------
Score: 54.94386904218915
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    # If the dict is empty, return None
    if not sorted_combinations:
        return None

    # Find the maximum number of points that can be covered
    max_points = max(len(points) for points in sorted_combinations.values())

    # Find the tasks that can cover the maximum number of points. 
    # If there are multiple tasks, select the one with the smallest satellite index.
    # If there are still multiple tasks, select the one with the smallest pass index.
    # If there are still multiple tasks, select the one with the smallest task index.
    top_tasks = [(sat_id, pass_id, task_id) for (sat_id, pass_id, task_id), points in sorted_combinations.items() if len(points) == max_points]
    top_tasks.sort()

    # Return the prioritised task
    return top_tasks[0]
-----------------------------------------------------
Score: 55.11494010904575
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Improved version of the priority_v0 function to prioritize the task based on its coverage, satellite index, and pass index.
    It checks the coverage of each task and prioritize those with higher coverage first.
    If two tasks have the same coverage, then the task with lower satellite index is prioritised.
    If two tasks have the same coverage and satellite index, then the task with lower pass index is prioritised.
    
    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    # Convert dictionary keys to list and initialize max coverage to negative infinity
    sorted_keys = list(sorted_combinations.keys())
    max_coverage = -float('inf')
    prioritized_task = None

    # Iterate over sorted keys
    for key in sorted_keys:
        current_coverage = len(sorted_combinations[key])

        # Update max coverage and prioritised task if current task has higher coverage
        if current_coverage > max_coverage:
            max_coverage = current_coverage
            prioritized_task = key
        # If current task has the same coverage as max coverage so far,
        # prioritize the task if it has a lower satellite index or pass index
        elif current_coverage == max_coverage:
            if key[0] < prioritized_task[0] or (key[0] == prioritized_task[0] and key[1] < prioritized_task[1]):
                prioritized_task = key

    # return the prioritized task
    return prioritized_task if prioritized_task else sorted_keys[0] if sorted_keys else None
-----------------------------------------------------
Score: 54.99676043852201
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Improved version of `priority_v0`.

    In this version, it will try to find the task that covers the most points first.
    If multiple tasks have the maximum coverage, it will then select the task that has the earliest start time. 
    If there are also multiple tasks start at the same time, then it selects base on the satellite index, pass index and task index sequentailly.
    """
    # Get the maximum coverage count among all tasks
    max_coverage_count = max([len(coverage) for coverage in sorted_combinations.values()])

    # Filter out tasks that have the max coverage
    max_coverage_tasks = {k: v for k, v in sorted_combinations.items() if len(v) == max_coverage_count}

    # If there's only one task with max coverage, return it
    if len(max_coverage_tasks) == 1:
        return list(max_coverage_tasks.keys())[0]

    # If there are multiple task with max coverage, sort them by satellite index, pass index and task index sequentailly
    sorted_max_coverage_tasks = sorted(max_coverage_tasks.keys())

    return sorted_max_coverage_tasks[0]
-----------------------------------------------------
Score: 55.11494010904575
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    based on a new prioritization strategy. Remove it from the list after it's selected.

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.
    """

    # start from the highest coverage...
    sorted_keys = sorted(sorted_combinations.keys(), key=lambda x: len(sorted_combinations[x]), reverse=True)

    for key in sorted_keys:
        # we choose only those tasks which are able to cover at least one point
        if len(sorted_combinations[key]) > 0:
            return key

    # if no task can cover any point, return the task that has the lowest index
    return sorted_keys[0] if len(sorted_keys) > 0 else None
-----------------------------------------------------
Score: 55.032021369410586
=====================================================


