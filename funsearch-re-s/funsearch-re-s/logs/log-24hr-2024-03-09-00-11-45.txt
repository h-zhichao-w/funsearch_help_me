================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    return list(sorted_combinations.keys())[-1]
-----------------------------------------------------
Score: 0.003400327932503444
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Get the combination of task id and its coverage that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM. This improved version considers 
    the situations where multiple tasks have the same number of coverages, preferencing the one comes first.

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    
    # Get the number of points that the last task can cover
    max_coverage = len(sorted_combinations[list(sorted_combinations.keys())[-1]])
    
    # Go through the tasks in reverse order
    for key in reversed(sorted_combinations.keys()):
        
        # If the task covers the same amount of points as the last task, then prioritize this task
        if len(sorted_combinations[key]) == max_coverage:
            return key

    # If no other task has the same coverage as the last task, then prioritize the last task
    return list(sorted_combinations.keys())[-1]
-----------------------------------------------------
Score: 0.003400327932503444
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Improved version of `priority_v0`. This version of the function also considers the number of points that a task can cover.
    However, if multiple tasks can cover the same number of points, this function checks the index of the task and prioritizes the task with the highest index.
    This approach ensures that, all else being equal, newer tasks (with higher indices) are prioritized.

    Args:
        sorted_combinations: Same as in `priority_v0`.

    Returns:
        tuple[int, int, int]: Same as in `priority_v0`.
    """
    max_priority_index = [-1, -1, -1]
    max_priority_coverage = -1
    for index, item in sorted_combinations.items():
        if len(item) > max_priority_coverage:
            max_priority_index = index
            max_priority_coverage = len(item)
        elif len(item) == max_priority_coverage:
            if index[2] >= max_priority_index[2]:
                max_priority_index = index
    return max_priority_index
-----------------------------------------------------
Score: 0.15160734175853463
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """Improved version of `priority_v0`."""
    
    sorted_key_list = list(sorted_combinations.keys())

    # The strategy here is to find the task with maximum coverage.
    # If multiple tasks have the same coverage, pick the one with least index (i.e., the earliest one).
    max_len = len(sorted_combinations[sorted_key_list[-1]])
    priorities = [key for key in sorted_key_list if len(sorted_combinations[key]) == max_len]
    
    # sort the task indices in ascending order
    priorities.sort()

    return priorities[0] # return the task with the smallest index.
-----------------------------------------------------
Score: 0.5309401090457477
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Improved version of `priority_v0`.
    
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list. The criterion for prioritisation is:
        - The task that can cover the most points is prioritised.
        - If two tasks can cover the same number of points, the task whose corresponding satellite has the lowest number of tasks remaining is prioritised.
        - If there is still a tie, randomly select a task.

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.
    """

    keys = list(sorted_combinations.keys())
    values = list(sorted_combinations.values())
    number_of_points_covered = [len(value) for value in values]

    max_number_of_points_covered = max(number_of_points_covered)
    indices_with_max_number_of_points_covered = [idx for idx, value in enumerate(number_of_points_covered) if value == max_number_of_points_covered]

    if len(indices_with_max_number_of_points_covered) == 1:
        return keys[indices_with_max_number_of_points_covered[0]]
    else:
        satellites_with_max_number_of_points_covered = [keys[idx][0] for idx in indices_with_max_number_of_points_covered]
        number_of_tasks_remaining_for_each_satellite = [sum([1 for key in keys if key[0] == satellite]) for satellite in satellites_with_max_number_of_points_covered]
        min_number_of_tasks_remaining = min(number_of_tasks_remaining_for_each_satellite)
        indices_with_min_number_of_tasks_remaining = [idx for idx, value in enumerate(number_of_tasks_remaining_for_each_satellite) if value == min_number_of_tasks_remaining]

        if len(indices_with_min_number_of_tasks_remaining) == 1:
            return keys[indices_with_min_number_of_tasks_remaining[0]]
        else:
            return keys[np.random.choice(indices_with_min_number_of_tasks_remaining)]
-----------------------------------------------------
Score: -54.35480394922426
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_coverage = max(len(sorted_combinations[key]) for key in sorted_combinations.keys())
    
    # create a list of combinations with max coverage
    max_coverage_combinations = [key for key in sorted_combinations.keys() if len(sorted_combinations[key]) == max_coverage]
    
    if len(max_coverage_combinations) == 1:
        # if there is only one combination with max coverage, return it
        return max_coverage_combinations[0]
    else:
        # if there are multiple combinations with max coverage, return the one with smallest satellite index
        return min(max_coverage_combinations, key=lambda x: x[0])
-----------------------------------------------------
Score: 0.35986904218914617
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Improved version of `priority_v0`. In this version, we give more priority to the task which covers
    more unique points. This heps to ensure more points are covered overall.

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, 
        in the format of [index of satellite, index of pass, index of task], and the value is a tuple,
        containing the indices of points that can be covered by the task. The tuple is likely to be empty, 
        and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending 
        order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.
    """
    
    # initialize empty set for all points
    all_points = set()

    # iterate over sorted_combinations in reverse order (higher priority first)
    for key in sorted(sorted_combinations.keys(), reverse=True):
        # get unique points from current task
        unique_points = set(sorted_combinations[key]) - all_points

        # if there are unique points, update all_points and return current key
        if unique_points:
            all_points.update(unique_points)
            return key

    # if no unique points, return last key
    return list(sorted_combinations.keys())[-1]
-----------------------------------------------------
Score: -10.579586243675841
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    This function prioritizes the task that covers the most points. But if two tasks cover the same number of points, 
    this function gives priority to the task that is performed by the satellite with the lower index.
    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. 
    The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, 
    containing the indices of points that can be covered by the task. 
    The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. 
    The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_coverage = None
    priority_task = None

    for task, coverage in sorted_combinations.items():
        if not max_coverage or len(coverage) > len(max_coverage):  # Finds the task with the most coverage
            max_coverage = coverage
            priority_task = task
        elif len(coverage) == len(max_coverage):  # If two tasks have the same coverage, prioritize lower-indexed satellite
            if task[0] < priority_task[0]:
                priority_task = task

    return priority_task if priority_task else list(sorted_combinations.keys())[-1]  # Return the last task if no task was found with coverage.
-----------------------------------------------------
Score: 0.35986904218914617
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """Improved version of `priority_v1`."""
    """
    This function prioritizes the task that covers the most points. But if two tasks cover the same number of points, 
    this function gives priority to the task that is performed by the satellite with the lower index. If both tasks are performed by the same satellite, it gives priority to the task associated with the lower pass index, and if they are still equal, the lower task index.
    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. 
    The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. 
    The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_coverage = None
    priority_task = None

    for task, coverage in sorted_combinations.items():
        if not max_coverage or len(coverage) > len(max_coverage):  # Finds the task with the most coverage
            max_coverage = coverage
            priority_task = task
        elif len(coverage) == len(max_coverage):  
            if task[0] < priority_task[0]:  # Prioritize lower-indexed satellite
                priority_task = task
            elif task[0] == priority_task[0]:  # If both tasks are performed by same satellite
                if task[1] < priority_task[1]:  # Prioritize lower pass index
                    priority_task = task
                elif task[1] == priority_task[1]:  # If both tasks have same pass index
                    if task[2] < priority_task[2]:  # Prioritize lower task index
                        priority_task = task

    return priority_task if priority_task else list(sorted_combinations.keys())[-1]  # Return the last task if no task with coverage is found.
-----------------------------------------------------
Score: 0.5309401090457477
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """Improved version of `priority_v1`."""
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    This function prioritizes the task that covers the most points. If two tasks cover the same number of points, 
    it gives priority to the task that is performed by the satellite with the lower index. In case of a tie, 
    the priority will be given to the task with the lowest pass index and if it's also a tie, to the one with the lowest task index.
    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. 
    The key is a tuple, in the format of [index of satellite, pass index, task index], and the value is a tuple, 
    containing the indices of points that can be covered by the task.
    The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. 
    The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_coverage = None
    priority_task = None

    for task, coverage in sorted_combinations.items():
        if not max_coverage or len(coverage) > len(max_coverage):  # Finds the task with the most coverage
            max_coverage = coverage
            priority_task = task
        elif len(coverage) == len(max_coverage):  # If two tasks have the same coverage
            if task[0] < priority_task[0]:  # prioritize lower-indexed satellite
                priority_task = task
            elif task[0] == priority_task[0]:  # If two tasks are on the same satellite 
                if task[1] < priority_task[1]:  # prioritize lower-indexed pass
                    priority_task = task
                elif task[1] == priority_task[1]:  # If two tasks are on the same pass
                    if task[2] < priority_task[2]:  # prioritize lower-indexed task
                        priority_task = task
                        
    return priority_task if priority_task else list(sorted_combinations.keys())[-1]  # Return the last task if no task was found with coverage.
-----------------------------------------------------
Score: 0.5309401090457477
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Get the combination of task id and its coverage from the sorted combinations.
    This function prioritizes the task that covers the most points. 
    But if multiple tasks cover the same number of points, this function gives priority to 
    the task that is performed by the satellite with the lower index. 
    In case of further ties, it prioritizes based on the order: lower pass index and lower task index.
    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. 
    The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. 
    The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. 
    The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_coverage = None
    priority_task = None

    for task, coverage in sorted_combinations.items():
        if not max_coverage or len(coverage) > len(max_coverage):  
            # Finds the task with the most coverage
            max_coverage = coverage
            priority_task = task
        elif len(coverage) == len(max_coverage):  
            # If two tasks have the same coverage, prioritize lower-indexed satellite.
            # In case of further ties, prioritize lower pass index and lower task index
            if task[0] < priority_task[0] or (task[0] == priority_task[0] and task[1] < priority_task[1]) or (task[0] == priority_task[0] and task[1] == priority_task[1] and task[2] < priority_task[2]):
                priority_task = task

    return priority_task if priority_task else list(sorted_combinations.keys())[-1]  # Return the last task if no task was found with coverage.
-----------------------------------------------------
Score: 0.5309401090457477
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    max_coverage = None
    priority_task = None

    for task, coverage in sorted_combinations.items():
        if not max_coverage or len(coverage) > len(max_coverage):  # Finds the task with the most coverage
            max_coverage = coverage
            priority_task = task
        elif len(coverage) == len(max_coverage):  
            # If coverage is same then, prioritize lower-indexed satellite
            # and task which comes first (earlier timestamp)
            if task[0] < priority_task[0] or (task[0] == priority_task[0] and task[1] < priority_task[1]):
                priority_task = task

    return priority_task if priority_task else list(sorted_combinations.keys())[-1]  # Return the last task if no task was found with coverage.
-----------------------------------------------------
Score: 0.4127604385220103
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    This function checks the sorted combinations from the end (one with the highest priority)
    and chooses the first that is not an empty task (a task that cannot cover any point).
    If all tasks are empty, it will return the first task in the dictionary.
    
    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, 
        in the format of [index of satellite, index of pass, index of task], and the value is a tuple, 
        containing the indices of points that can be covered by the task. The tuple is likely to be empty, 
        and if so, it means that the corresponding task cannot cover any point. 
        
    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.
    """
    # Starting from the end of the sorted list
    for task in list(sorted_combinations.keys())[::-1]:
        # If task is not empty
        if sorted_combinations[task]:
            # Return that task
            return task

    # If all tasks are empty, return the first task
    return list(sorted_combinations.keys())[0]
-----------------------------------------------------
Score: 0.003400327932503444
=====================================================


================= Evaluated Program =================
def priority(sorted_combinations: dict) -> tuple[int, int, int]:
    """
    Get the combination of task id and its coverage that that should be prioritised from the sorted combinations,
    and remove it from the list.
    The function that determine the priority should be generated by LLM

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple, in the format of [index of satellite, index of pass, index of task], and the value is a tuple, containing the indices of points that can be covered by the task. The tuple is likely to be empty, and if so, it means that the corresponding task cannot cover any point. The dict is sorted in ascending order on the number of points that can be covered.

    Returns:
        tuple[int, int, int], the combination that is prioritised,
        in the format of [satellite index, pass index, task index], i.e. the key of the prioritised task.

    """
    """
    Improved version of `priority_v0` in which we choose the task which covers maximum unique points that have not been covered by any other task before. This approach hence maximizes the coverage of points.

    Args:
        sorted_combinations: dict, sorted combinations of task id and its coverage. The key is a tuple of (satellite index, pass index, task index), and the value is a list of point indices that can be covered by that task. If list is empty, it means that the corresponding task cannot cover any point.

    Returns:
        tuple[int, int, int], the task (key) that covers maximum unique points, in format (satellite index, pass index, task index).
    """
    # Initialize a list to keep track of covered points 
    covered_points = []

    # Iterate over the sorted_combinations
    for task, task_points in sorted_combinations.items():

        # Check if task covers any new point
        new_points = [point for point in task_points if point not in covered_points]

        # If some new points are covered, prioritize this task and update covered_points
        if new_points:
            covered_points.extend(new_points)
            return task

    # Return last task in sorted_combinations if no task covers new points
    return list(sorted_combinations.keys())[-1]
-----------------------------------------------------
Score: -17.064849162742938
=====================================================


